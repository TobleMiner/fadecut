#!/bin/bash
#
# This file is part of fadecut
# https://github.com/micressor/fadecut
#
# fadecut is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# fadecut is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with fadecut.  If not, see <http://www.gnu.org/licenses/>.

# Constants --------------------------------------------------------------------
# Debug level 0-3
DEBUG=0

# fadecut's pid
PID=$$

# Verbosity level
VERBOSE=0

# loop interval in seconds
LOOP_INTERVAL=10

# restart interval streamripper
RESTART_STREAMRIPPER_INTERVAL=900

# which files to work on
FILES=*.mp3

# Main directory of fadecut
PWD=`pwd`

# prefered destination fileformat. (ogg/mp3)
ENCODING=ogg

# trim start- and endpoint of cut in seconds
TRIM_BEGIN=0
TRIM_END=0

# seconds to fade in 
FADE_IN=1

# seconds to fade out
FADE_OUT=4

# fadecut's logdir
LOGDIR=/tmp
# fadecut's profile dir
PROFILEDIR="${HOME}/.fadecut" 

# fadecut's workdir
WORKDIR="${PWD}"

# where to put fadecut'ted files
OUTPUTDIR="${PWD}/new"

# where to put the uncutted original files
ORIGDIR="${PWD}/orig"

# here are the already fadecut'ted files, which are tested and we listened to 
# already
DONEDIR="${PWD}/done"

# here we put songs which we don't like
DONTLIKEDIR="${PWD}/dontlike"

# here are the files, with which we got an error
# in same folder i put files, which i was listening to and found advertisement 
# or bad cutting
ERRORDIR="${PWD}/error"

# here will be the files which we have already downloaded and which we got again
DOUBLEDIR="${PWD}/double"

# where to put temporary files
TMPDIR=/tmp

# enqueue to rhythmbox or vlc player (0=false, 1=true)
ENQUEUE=0

# standard errorlevel definitions
E_NOARGS=65

# start streamripper
STREAMRIPPER_START=0 

# define all binaries
BIN_STREAMRIPPER=$(which streamripper)
BIN_SOX=$(which sox)
BIN_MP3SPLT=$(which mp3splt)
BIN_OGGINFO=$(which ogginfo)
BIN_OGGENC=$(which oggenc)
BIN_MP3INFO=$(which mp3info)
BIN_ID3V2=$(which id3v2)
BIN_LAME=$(which lame)


# streamripper options
STREAMRIPPER_OPTS="-o always -T"

# Variables --------------------------------------------------------------------
PidStreamripper="-1"
IdleCounter=-1
IdleSeconds=0
MissingVar=""
Fdst=""
# Functions --------------------------------------------------------------------

usage()
{
cat << EOF

usage: $0 -p <profilename> [other options]

OPTIONS:
  -c    create profile <profilename>
  -e    edit profile <profilename>
  -i    optional input directory
  -o    optional output directory
  -d    Debug: -d 0|1|2|3 (level 0 is standard, -d without number is like 1)
  -h	Show this message
  -p    Profile <profilename>
  -q	Quiet
  -s    Stream (and rip), start streamripper
  -v	Verbose

EOF
}

logging()
#
# Description:  It writes messages to logfile or standard output.
#
# Parameter  :  $1 - the level of message
#               $2 - the message
#
# Std. Output:  Logging messages.
#
{
 time="$(date +%H):$(date +%M):$(date +%S)"
 prefix=""
 stderr=-1

 case $1 in
   -e)     prefix="Error:   " stderr=1 verbose=0;;
   -i)     prefix="Info:    " stderr=0 verbose=0;;
   -n)     prefix="Notice:  " stderr=0 verbose=1;;
   -s)     prefix="Success: " stderr=0 verbose=0;;
   -w)     prefix="Warning: " stderr=1 verbose=1;;
   -d)     prefix="Debug:   " stderr=1 verbose=2;;
   -a)     prefix="         " stderr=1 verbose=0;;
   -r)     prefix="Stream:  " stderr=0 verbose=0;;
 esac
 shift

# We need to document this better!
if [ ${verbose} -ge 1 ] && [ ${VERBOSE} -ge 1 ] ; then 
 if [ "${stderr}" -eq 1 ]; then
   echo "${time} ${prefix}" ${1} >&2
 else
   echo "${time} ${prefix}" ${1}
 fi
elif [ ${verbose} -eq 0 ] ; then
 if [ "${stderr}" -eq 1 ]; then
   echo "${time} ${prefix}" ${1} >&2
 else
   echo "${time} ${prefix}" ${1}
 fi
fi
}

createDirs()
# create necessary directories
{
if [ ${DEBUG} -ge 3 ]; then set -x
fi

if [ ! -d "${PROFILEDIR}/profiles" ]; then
  mkdir -p "${PROFILEDIR}/profiles"
fi

return 0
}

startStream()
# fork a stream process
{
if [ ${DEBUG} -ge 3 ]; then set -x
fi

cd "${WORKDIR}"

if [ ! -x ${BIN_STREAMRIPPER} ]; then
  logging -e "Ooops! No streamripper found"
  shutdown_fadecut
fi

if [ ! -d "/proc/${PidStreamripper}" ] && [ "$STREAMRIPPER_START" == "1" ];
then
  ${BIN_STREAMRIPPER} ${STREAM_URL} -d . \
                      --codeset-filesys=utf8 \
                      --codeset-id3=ISO-8859-1 \
                      -s ${STREAMRIPPER_OPTS} \
                      > ${LOGDIR}/fadecutstream-${PID}.log 2>&1 & 
  PidStreamripper=$!
  logging -s "${BIN_STREAMRIPPER} started pid=${PidStreamripper}"
else
  logging -n "${BIN_STREAMRIPPER} running pid=${PidStreamripper}"
fi

cd "${PWD}"

return 0
}

shutdown_streamripper()
# Shutting down streamripper
{
if [ ${DEBUG} -ge 1 ]; then set -x
fi

TmpPid=$(pidof streamripper)

if [ -z ${TmpPid} ]; then return 0
fi

if [ $TmpPid -eq $PidStreamripper ];
then
  logging -i "Shuting down streamripper" 
  kill ${PidStreamripper} 
  sleep 1
  if [ "$(pidof streamripper)" ];
  then
    logging -w "Streamripper still here, killing it!"
    kill -9 ${PidStreamripper}
  fi
else
  logging -n "Another streamripper is still running"
fi
}

shutdown_fadecut()
# shutting down fadecut
{
if [ ${DEBUG} -ge 1 ]; then set -x
fi

shutdown_streamripper
showStats
if [ -f "${LOGDIR}/fadecutstream-${PID}.log" ] ; then
  rm ${LOGDIR}/fadecutstream-${PID}.log
fi
logging -i "Shutting down fadecut..."
exit $?
}

queueSong()
# queue song to music players
{
if [ ${DEBUG} -ge 2 ]; then set -x
fi

if [ $ENQUEUE -eq "1" ]; then
  if [ "$(pidof rhythmbox)" ];
  then
    logging -i "Rhythmbox is running, adding to playlist"
    rhythmbox-client --enqueue "$OUTPUTDIR"/"$Fdst"
  fi
  if [ "$(pidof vlc)" ];
  then
    # enqueue to vlc player if in one instance mode (default disabled)
    logging -i "vlc is running, adding to playlist"
    vlc --playlist-enqueue "$OUTPUTDIR"/"$Fdst" > /dev/null 2>&1
  fi
fi
}

control_c()
# run if user hits control-c
{
if [ ${DEBUG} -ge 3 ]; then set -x
fi

logging -n "CTRL-C catched"
shutdown_fadecut
}

loop_fadecut()
{
if [ ${DEBUG} -ge 3 ]; then set -x
fi

RetLoop=0

cd "${WORKDIR}"
for F in $FILES
do
  # if there are no more files to process, go to idle state or clean up
  # and shutdown fadecut.
  if [ "$F" == "$FILES" ]; then
    let IdleCounter=$((IdleCounter+1))
    let IdleSeconds=$((IdleCounter*LOOP_INTERVAL))
    logging -n "no files to process, idle for ${IdleSeconds} seconds"
    if [ $STREAMRIPPER_START == "0" ];
    then 
      shutdown_fadecut
    else
      if [ ${IdleSeconds} -ge ${RESTART_STREAMRIPPER_INTERVAL} ];
      then
        logging -w "Oops! Seems to hang, restarting it"
	shutdown_streamripper
	startStream
        IdleCounter=0
      fi
    fi
    break
  fi
  IdleCounter=0

  # Checking part of loop_fadecut()
  # check next file 
  logging -i "Processing:"
  logging -a "$F"
  
  Fstatus=processing
  Fnew=$(filerename $F)
  # Converting id3v1->id3v2 tags, if necessary. Must be before `id3v2 -l`
  # command.
  id3v2 -C "$F" > /dev/null 2>&1
  ARTIST=`id3v2 -l "$F" | sed -e '/TPE1/!d' -e 's/^.*: //g'`
  TITLE=`id3v2 -l "$F" | sed -e '/TIT2/!d' -e 's/^.*: //g'`
  LENGTH=`mp3info -p "%S" "$F"`

  # do some checks, check if file already exists and set status
  # status will be written to statslog
  # depending on status the processing will continue or will skipped to next file
  if [[ -z $ARTIST ]] || [[ -z $TITLE ]] || [[ -z $LENGTH ]]
  then
    logging -e "could not get mp3 tags from source file."
    logging -e "ARTIST: $ARTIST / TITLE: $TITLE / LENGTH: $LENGTH"
    move_file "$F" "$ERRORDIR"
    Fstatus=error-notags
  elif [ -f "$DONEDIR"/"$F" ] || [ -f "$DONEDIR"/"$Fnew" ] ; then
    logging -i "File already exists in $DONEDIR -> remember as double and deleting ..."
    double_file "$F" "$DOUBLEDIR"
    Fstatus=double-done
  elif [ -f "$OUTPUTDIR"/"$F" ] || [ -f "$OUTPUTDIR"/"$Fnew" ] ; then
    logging -i "File already exists in $OUTPUTDIR -> remember as double and deleting ..."
    double_file "$F" "$DOUBLEDIR"
    Fstatus=double-output
  elif [ -f "$DONTLIKEDIR"/"$F" ] || [ -f "$DONTLIKEDIR"/"$Fnew" ] ; then
    logging -i "I don't like. File exists in $DONTLIKEDIR -> deleting ..."
    rm "$F"
    Fstatus=dontlike
  fi
  
  writeStats "$ARTIST" "$TITLE" "$GENRE" "$PROFILE" "$Fstatus"

  # skip processing of current file if it is "double" or "don't like"
  if [[ $Fstatus != processing ]] ; then
    continue
  fi

  # Processing part of loop_fadecut()

  let TRIMLENGTH=$((LENGTH-TRIM_BEGIN-TRIM_END))
  let FADE_OUT_START=$((TRIMLENGTH-FADE_OUT))

  splitting "${F}"

  if [ "${ENCODING}" == "mp3" ]; then
    mp3Encoding "${F}"
  fi
  if [ "${ENCODING}" == "ogg" ]; then
    oggEncoding "${F}"
  fi
  
  if [ "${RetLoop}" -eq "0" ]; then
    logging -s "Ready for listening:"
    logging -a "$Fdst"
    move_file "$F" "$ORIGDIR"
  else
    move_file "$F" "$ERRORDIR"
      # when sox or lame are receiving SIGINT they exit with return-code > 0
      # the ctrl_c function does not catch this case, so we have to break here
    logging -n "loop_fadecut(): Oops! Something was wrong."
    logging -e "loop_fadecut(): returnvalue=$RetLoop"
    shutdown_fadecut
  fi

  queueSong
  showStats
done
cd "${PWD}"
}

load_profile()
{
if [ ${DEBUG} -ge 2 ]; then set -x
fi

createDirs
logging -i "Loading profile file(s):"

if [ -r "${PROFILEDIR}/fadecutrc" ]; then
  logging -a "${PROFILEDIR}/fadecutrc"
  . "${PROFILEDIR}/fadecutrc"
fi

if [ ! -r "${PROFILEDIR}/profiles/${PROFILE}" ]; then
  logging -e "Can't not load profile ${PROFILEDIR}/profiles/${PROFILE}"
  exit 1
fi

logging -a "${PROFILEDIR}/profiles/${PROFILE}"
. "${PROFILEDIR}/profiles/${PROFILE}"

check_profile
}

create_profile()
# creating a profile
{
if [ ${DEBUG} -ge 2 ]; then set -x
fi

NEW=${1}

echo \
"STREAM_URL=\"http://radiostream\"
GENRE=\"YourGenre\"
COMMENT=\"Your Comment\"
# all values in seconds:
FADE_IN=1
FADE_OUT=4
# TRIM_BEGIN=0
# TRIM_END=0" > "${PROFILEDIR}/profiles/${NEW}"
logging -i "Starting vim editor"
vi "${PROFILEDIR}/profiles/${NEW}"
logging -i "Now start: fadecut -p ${NEW} -s"
}

edit_profile()
# creating a profile
{
vi "${PROFILEDIR}/profiles/${1}"
}

check_profile()
# Check profile, we need all variables to work
{
if [ ${DEBUG} -ge 2 ]; then set -x
fi

RetCheckProfile=0
MissingVar=""

if [ -z "$STREAM_URL" ]; then 
  RetCheckProfile=1
  MissingVar="STREAM_URL"
fi
if [ -z "$COMMENT" ]; then 
  RetCheckProfile=1
  MissingVar="COMMENT"
fi
if [ -z "$TRIM_BEGIN" ]; then 
  RetCheckProfile=1
  MissingVar="TRIM_BEGIN"
fi
if [ -z "$TRIM_END" ]; then 
  RetCheckProfile=1
  MissingVar="TRIM_END"
fi
if [ -z "$FADE_IN" ]; then 
  RetCheckProfile=1
  MissingVar="FADE_IN"
fi
if [ -z "$FADE_OUT" ]; then 
  RetCheckProfile=1
  MissingVar="FADE_OUT"
fi

if [ ${RetCheckProfile} -eq 1 ]; 
then 
  logging -e "${PROFILEDIR}/profiles/${PROFILE}:"
  logging -a "${MissingVar} not defined"
  shutdown_fadecut
fi
}

showStats()
# Show file statistics
{
if [ ${DEBUG} -ge 3 ]; then set -x
fi

# show statistics only, if all directories are existing
if [ -d "${OUTPUTDIR}" ]; then
  StatsNewDir=`ls -1 "${OUTPUTDIR}" | wc -l`
fi
if [ -d "${ORIGDIR}" ]; then
  StatsOrigDir=`ls -1 "${ORIGDIR}"  | wc -l`
fi
if [ -d "${DONEDIR}" ]; then
  StatsDoneDir=`ls -1 "${DONEDIR}"  | wc -l`
fi
if [ -d "${DONTLIKEDIR}" ]; then
  StatsDontlikeDir=`ls -1 "${DONTLIKEDIR}"  | wc -l`
fi
if [ -d "${ERRORDIR}" ]; then
  StatsErrorDir=`ls -1 "${ERRORDIR}"  | wc -l`
fi
if [ -d "${DOUBLEDIR}" ]; then
  StatsDoubleDir=`ls -1 "${DOUBLEDIR}"  | wc -l`
fi
  logging -i "showStats:"
  logging -a "Output:${StatsNewDir} Orig:${StatsOrigDir} Done:${StatsDoneDir} Dontlike:${StatsDontlikeDir} Error:${StatsErrorDir} Double:${StatsDoubleDir}"

if [ -f "${PROFILEDIR}"/statslog.csv ]; then
  double=`grep double "${PROFILEDIR}"/statslog.csv | wc -l`
  processed=`grep processing "${PROFILEDIR}"/statslog.csv | wc -l`
  ratio=$(echo "scale=2; $processed/$double" | bc)
  logging -a "stats log: double:${double} processed:${processed} processed/double-ratio:${ratio}"
fi
}

writeStats()
# Write statistics log
# writeStats "artist" "title" "genre" "profile"
{
if [ ${DEBUG} -ge 1 ]; then set -x
fi

date=`date +%d.%m.%Y`
time=`date +%H:%M:%S`
artist=`echo "$1" | iconv -f ISO-8859-1 -t UTF-8`
title=`echo "$2"  | iconv -f ISO-8859-1 -t UTF-8`
genre="$3"
profile="$4"
status="$5"
echo "$date;$time;$artist;$title;$genre;$profile;$status" >> "$PROFILEDIR"/statslog.csv
}

oggEncoding()
# Encoding to ogg
{
if [ ${DEBUG} -ge 1 ]; then set -x
fi

Fsrc="$*"
Ftmp=$(echo $Fsrc | sed 's/.mp3/.ogg/g')
Fdst=$(filerename $Ftmp)
if [ ! -d "$OUTPUTDIR" ]; then
  mkdir -p "$OUTPUTDIR"
fi
# The Bash ‘-o pipefail’ option to set will cause a pipeline to return a 
# failure status if any command fails. 
set -o pipefail
nice -15 sox -V1 "$F" -t wav - trim $TRIM_BEGIN $TRIMLENGTH \
  fade t $FADE_IN $FADE_OUT_START $FADE_OUT | \
  oggenc - --quiet -t "$TITLE"  -a  "$ARTIST" -G "$GENRE" \
	-c "comment=$COMMENT" -o "$OUTPUTDIR"/"$Fdst" || RetLoop=3
# Disable pipefail (default)
set +o pipefail
if [ ${VERBOSE} -ge 1 ];
then
  ogginfo "$OUTPUTDIR"/"$Fdst" || RetLoop=3
fi
}

mp3Encoding()
# Encoding to mp3
{
if [ ${DEBUG} -ge 1 ]; then set -x
fi

Fsrc="$*"
Fdst=$(filerename $Fsrc)
if [ ! -d "$OUTPUTDIR" ]; then
  mkdir -p "$OUTPUTDIR"
fi
# The Bash ‘-o pipefail’ option to set will cause a pipeline to return a 
# failure status if any command fails. 
set -o pipefail
nice -15 sox -V1 "$Fsrc" -t wav - trim $TRIM_BEGIN $TRIMLENGTH \
  fade t $FADE_IN $FADE_OUT_START $FADE_OUT | \
  lame --quiet --add-id3v2 --ta "$ARTIST" --tt "$TITLE" \
  --tg "$GENRE" --tc "$COMMENT" - "$OUTPUTDIR"/"$Fdst" || RetLoop=3
# Disable pipefail (default)
set +o pipefail
}

splitting()
# split files using silence detection
{
F="$*"
Fwoext=$(echo $F | sed 's/.mp3//g')
if [ ${DEBUG} -ge 1 ]; then 
  mp3splt -N -s -p rm,nt=3 "$F" 
elif [ ${VERBOSE} -ge 1 ]; then
  mp3splt -q -N -s -p rm,nt=3 "$F"
else
  mp3splt -q -N -s -p rm,nt=3 "$F" > /dev/null 2>&1
fi
Ftmp=`ls -1S "$Fwoext"* | head -1`
if [ "$Ftmp" != "$F" ] ; then
  mv "$Ftmp" "$F"
fi
rm -f "$Fwoext"_silence_*.*
}

filerename()
# rename filenames
{
if [ ${DEBUG} -ge 2 ]; then set -x
fi

Fnold="$*"
Fnnew=$(echo $Fnold | sed -e 's/ /_/g' -e 's/\(.*\)/\L\1/')
echo $Fnnew
}

checkRequirements()
# Check if all necessary tools and binaries are available
{
if [ ${DEBUG} -ge 3 ]; then set -x
fi

logging -d "Checking fadecut requirements"
if [ -z ${BIN_STREAMRIPPER} ]; then RequirementsMsg=streamripper
fi
if [ -z ${BIN_SOX} ]; then RequirementsMsg=sox
fi
if [ -z ${BIN_MP3SPLT} ]; then RequirementsMsg=mp3splt
fi
if [ -z ${BIN_MP3INFO} ]; then RequirementsMsg=mp3info
fi
if [ -z ${BIN_ID3V2} ]; then RequirementsMsg=id3v2
fi

if [ "${ENCODING}" == "ogg" ];
then
  if [ -z ${BIN_OGGINFO} ]; then RequirementsMsg=ogginfo
  fi
  if [ -z ${BIN_OGGENC} ]; then RequirementsMsg=oggenc
  fi
fi

if [ "${ENCODING}" == "mp3" ];
then
  if [ -z ${BIN_LAME} ]; then RequirementsMsg=lame
  fi
fi

if [ ! -z ${RequirementsMsg} ];
then
  logging -e "Program ${RequirementsMsg} not installed or not in PATH"
  return 1
fi
return 0
}

move_file()
#checks if directory exists, creates it if necessary and moves file to it
# $1 = file
# $2 = destination directory
{
if [ ${DEBUG} -ge 1 ]; then set -x
fi

if [ ! -d "$2" ]; then
  mkdir -p "$2"
fi
mv "$1" "$2"
}

double_file()
#checks if directory exists, creates it if necessary and creates 0bytes file
# $1 = file
# $2 = destination directory
{
if [ ${DEBUG} -ge 1 ]; then set -x
fi

if [ ! -d "$2" ]; then
  mkdir -p "$2"
fi
touch "$2"/"$1"
rm "$1"
}

# Main  ------------------------------------------------------------------------

# trap keyboard interrupt (control-c)
trap control_c SIGINT

while getopts ":d:hp:c:e:i:o:qsv" OPTION
do
# When you need an argument that needs a value, you put the ":" right after 
# the argument in the optstring. If your var is just a flag, withou any 
# additional argument, just leave the var, without the ":" following it.
  case $OPTION in
    d)
      DEBUG=$OPTARG
      ;;
    h)
      usage
      exit 1
      ;;
    p)
      PROFILE=$OPTARG
      load_profile
      if ! checkRequirements; then shutdown_fadecut
      fi
      ;;
    c)
      create_profile $OPTARG
      exit 0
      ;;
    e)
      edit_profile $OPTARG
      exit 0
      ;;
    i)
      WORKDIR=${OPTARG}
      if [ ! -d "${WORKDIR}" ];
      then
        logging -e "${WORKDIR}: Input directory does not exist"
        shutdown_fadecut
      fi
      logging -n "Using for input: ${WORKDIR}"
      ;;
    o)
      OUTPUTDIR=${OPTARG}
      if [ ! -d "${OUTPUTDIR}" ];
      then
        logging -e "${OUTPUTDIR}: Output directory does not exist"
        shutdown_fadecut
      fi
      logging -n "Using for output: ${OUTPUTDIR}"
      ;;
    q)
      DEBUG=0
      VERBOSE=0
      # add LOGGING variable and change logging function to be able to turn 
      # all output off
      ;;
    s)
      STREAMRIPPER_START=1 
      ;;
    v)
      VERBOSE=1
      ;;
    \?)
      logging -e "Invalid option: -$OPTARG" >&2
      usage
      shutdown_fadecut
      ;;
    :)
      logging -e "Option -$OPTARG requires an argument." >&2
      shutdown_fadecut
      ;;
  esac
done

if [ -z $PROFILE ] ; then
  usage
  exit 1
fi

if [ "${OUTPUTDIR}" = "${WORKDIR}" ];
then
  logging -e "Output and input directory can not be equal!"
  usage
  exit 1
fi

StreamInfo=""
StreamInfo2=""
while true
do
  startStream
  loop_fadecut
  logging -n "Main(): Loop until we're finished"
  sleep 2
  StreamInfo=$(tail -1 ${LOGDIR}/fadecutstream-${PID}.log | sed -e 's//\n/g' | tail -1 | sed -e 's/ \[.*$//g')
  if [ "$StreamInfo" != "$StreamInfo2" ] ; then
    logging -r "${StreamInfo}"
    StreamInfo2="$StreamInfo"
  fi
  sleep ${LOOP_INTERVAL}
done
