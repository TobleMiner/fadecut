#!/bin/bash
#
# This file is part of fadecut
# http://url
#
# fadecut is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# fadecut is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with fadecut.  If not, see <http://www.gnu.org/licenses/>.

# Constants --------------------------------------------------------------------
# Debug level 1-3
DEBUG=0

# Verbosity level
VERBOSE=0

# which files to work on
FILES=*.mp3

# Main directory of fadecut
PWD=`pwd`

# prefered destination fileformat. (ogg/mp3)
ENCODING=mp3

# preferred fadecut method. <sox|cutmp3>
METHOD=sox

# fadcut's workdir
WORKDIR=${PWD}/workdir

# where to put fadecut'ted files
OUTPUTDIR=${PWD}/new

# where to put the uncutted original files
ORIGDIR=${PWD}/orig

# here are the already fadecut'ted files, which are tested and we listened to 
# already
DONEDIR=${PWD}/done

# here we put songs which we don't like
DONTLIKEDIR=${PWD}/dontlike

# here are the files, with which we got an error
# in same folder i put files, which i was listening to and found advertisement 
# or bad cutting
ERRORDIR=${PWD}/error

# here will be the files which we have already downloaded and which we got again
DOUBLEDIR=${PWD}/double

# enqueue to rhythmbox or vlc player (0=false, 1=true)
ENQUEUE=0

# standard errorlevel definitions
E_NOARGS=65

# start streamripper
STREAMRIPPER_START=0 

# stream ripper binary
BIN_STREAMRIPPER="/usr/bin/streamripper"


# streamripper options
STREAMRIPPER_OPTS="--quiet -o always -T"

# Variables --------------------------------------------------------------------
PidStreamripper=""
# Functions --------------------------------------------------------------------

usage()
{
cat << EOF
usage: $0 -p <pop|chillout> [other options]

OPTIONS:
  -d    Debug: -d 0|1|2|3 (level 0 is standard, -d without number is like 1)
  -h	Show this message
  -m    Method <sox|cutmp3>
  -p    Profile <pop|chillout>
  -q	Quiet
  -s    Stream (and rip), start streamripper
  -v	Verbose
EOF
}

logging()
#
# Description:  It writes messages to logfile or standard output.
#
# Parameter  :  $1 - the level of message
#               $2 - the message
#
# Std. Output:  Logging messages.
#
{
 time="$(date +%H):$(date +%M):$(date +%S)"
 prefix=""

 case $1 in
   -e)     prefix="Error:   ";;
   -i)     prefix="Info:    ";;
   -n)     prefix="Notice:  ";;
   -s)     prefix="Success: ";;
   -w)     prefix="Warning: ";;
   -d)     prefix="Debug:   ";;
   -a)     prefix="         ";;
 esac
 shift
 echo "${time} ${prefix}" ${1}
}

createDirs()
# create necessary directories
{
if [ ${DEBUG} -ge 2 ]; then set -x
fi

if [ ! -d "$OUTPUTDIR" ]; then
  mkdir -p "$OUTPUTDIR"
fi

if [ ! -d "$ORIGDIR" ]; then
  mkdir -p "$ORIGDIR"
fi

if [ ! -d "$DONEDIR" ]; then
  mkdir -p "$DONEDIR"
fi

if [ ! -d "$DONTLIKEDIR" ]; then
  mkdir -p "$DONTLIKEDIR"
fi

if [ ! -d "$ERRORDIR" ]; then
  mkdir -p "$ERRORDIR"
fi

if [ ! -d "$DOUBLEDIR" ]; then
  mkdir -p "$DOUBLEDIR"
fi

if [ ! -d "$WORKDIR" ]; then
  mkdir -p "$WORKDIR"
fi

return 0
}

startStream()
# fork a stream process
{
if [ ${DEBUG} -ge 1 ]; then set -x
fi

cd ${WORKDIR}

if [ ! -x ${BIN_STREAMRIPPER} ]; then
  logging -e "Ooops! No streamripper found"
  shutdown_fadecut
fi

if [ ${VERBOSE} -ge 1 ];
then
  # opposite of quiet
  STREAMRIPPER_OPTS="-o always -T"
fi

if [ ! "$(pidof streamripper)" ] && [ "$STREAMRIPPER_START" == "1" ];
then
  ${BIN_STREAMRIPPER} ${STREAM_URL} -d . -s ${STREAMRIPPER_OPTS} & 
  PidStreamripper=$!
  logging -s "${BIN_STREAMRIPPER} started pid=${PidStreamripper}"
else
  logging -n "${BIN_STREAMRIPPER} running pid=${PidStreamripper}"
fi

cd ${PWD}

return 0
}

shutdown_fadecut()
# shutting down fadecut
{
if [ ${DEBUG} -ge 1 ]; then set -x
fi

logging -i "Shutting down fadecut..."
if [ "$(pidof streamripper)" ];
then 
  logging -i "Stopping streamripper" >&2
  kill ${PidStreamripper}
fi
exit $?
}

queueSong()
# queue song to music players
{
if [ $ENQUEUE -eq "1" ]; then
  if [ "$(pidof rhythmbox)" ];
  then
    logging -n "Rhythmbox is running, adding to playlist"
    rhythmbox-client --enqueue "$OUTPUTDIR"/"$FDST"
  fi
  if [ "$(pidof vlc)" ];
  then
    # enqueue to vlc player if in one instance mode (default disabled)
    logging -n "vlc is running, adding to playlist"
    vlc --playlist-enqueue "$OUTPUTDIR"/"$FDST"
  fi
fi
}

control_c()
# run if user hits control-c
{
if [ ${DEBUG} -ge 1 ]; then set -x
fi
  logging -n "CTRL-C catched" >&2
  shutdown_fadecut
}
# trap keyboard interrupt (control-c)
trap control_c SIGINT

loop_fadecut()
{
if [ ${DEBUG} -ge 1 ]; then set -x
fi
RetLoop=0

cd ${WORKDIR}
for F in $FILES
do
  if [ "$F" == "$FILES" ]; then
    logging -n "no files to process ..."
    if [ $STREAMRIPPER_START == "0" ];
    then 
      showStats
      shutdown_fadecut
    fi
    break
  fi

  logging -i "Processing:"
  logging -a "$F"

  if [ -f "$DONEDIR"/"$F" ]; then
    logging -i "$F already exists in $DONEDIR -> moving to $DOUBLEDIR ..."
    mv "$F" "$DOUBLEDIR"
    continue
  fi

  if [ -f "$DONTLIKEDIR"/"$F" ]; then
    logging -i "$F already exists in $DONTLIKEDIR -> deleting ..."
    rm "$F"
    continue
  fi

  set -o pipefail
  ARTIST=`echo $F | sed -e 's/ -.*//' | iconv -f UTF-8 -t ISO8859-1`
  TITLE=`echo $F | sed -e 's/^.* - //' | sed -e 's/.mp3//' | iconv -f UTF-8 -t ISO8859-1`

  if [ "$METHOD" == "sox" ]; then
    LENGTH=`soxi -D "$F" | sed -e 's/\..*//'`
    let TRIMLENGTH=$((LENGTH-TRIM_BEGIN-TRIM_END))
    let FADE_OUT_START=$((TRIMLENGTH-FADE_OUT))

    logging -i "Encoding to ${ENCODING}"
    if [ "${ENCODING}" == "mp3" ]; then
      FDST=${F}
      nice -15 sox -V1 "$F" -t wav - trim $TRIM_BEGIN $TRIMLENGTH \
    	fade t $FADE_IN $FADE_OUT_START $FADE_OUT | \
	nice -15 lame --quiet --add-id3v2 --ta "$ARTIST" --tt "$TITLE" \
	--tg "$GENRE" --tc "$COMMENT" - "$OUTPUTDIR"/"$FDST" || RetLoop=3
    fi

    if [ "${ENCODING}" == "ogg" ]; then
      FDST=$(echo $F | sed 's/.mp3/.ogg/g')
      nice -15 sox -V1 "$F" -t wav - trim $TRIM_BEGIN $TRIMLENGTH \
	fade t $FADE_IN $FADE_OUT_START $FADE_OUT | \
	oggenc - --quiet -t "$TITLE"  -a  "$ARTIST" -G "$GENRE" \
              -c "comment=$COMMENT" -o "$OUTPUTDIR"/"$FDST" || RetLoop=3
      if [ ${VERBOSE} -ge 1 ];
      then
        ogginfo "$OUTPUTDIR"/"$FDST" || RetLoop=3
      fi
    fi
  fi

  if [ "$METHOD" == "cutmp3" ]; then
    if [ "${ENCODING}" == "mp3" ]; then
      logging -i "cutting with cutmp3 ..."
      #quiet:
      #echo nnnnpwq | cutmp3 -i "$F" -O "$OUTPUTDIR"/"$F" -q -c &> /dev/null
      
      #verbose:
      echo nnnnnnpwq | cutmp3 -i "$F" -O "$OUTPUTDIR"/"$F" -q -c || RetLoop=3
    else
      logging -e "This method works only for mp3 encoding"
    fi
  fi
  
  if [ "${RetLoop}" -eq "0" ]; then
    logging -s "Ready for listening:"
    logging -a "$FDST"
    mv "$F" "$ORIGDIR"
  else
    mv "$F" "$ERRORDIR"
      # when sox or lame are receiving SIGINT they exit with return-code > 0
      # the ctrl_c function does not catch this case, so we have to break here
    logging -n "loop_fadecut(): Oops! Something was wrong."
    logging -e "loop_fadecut(): returnvalue=$RetLoop"
    shutdown_fadecut
  fi
  set +o pipefail

queueSong
done
cd ${PWD}
}

load_profile()
{
  if [ ! -r ./${PROFILE}.pro ]; then
    logging -e "Ooops! Can not load profile ${PROFILE}"
    exit 1
  fi
  logging -i "Loading profile ${PROFILE}"
  . ./${PROFILE}.pro || logging -e "Ooops!"
}

showStats()
# Show file statistics
{
StatsNewDir=`find ${OUTPUTDIR} -type f | wc -l`
StatsOrigDir=`find ${ORIGDIR} -type f | wc -l`
StatsDoneDir=`find ${DONEDIR} -type f | wc -l`
StatsDontlikeDir=`find ${DONTLIKEDIR} -type f | wc -l`
StatsErrorDir=`find ${ERRORDIR} -type f | wc -l`
StatsDoubleDir=`find ${DOUBLEDIR} -type f | wc -l`
logging -i "showStats: Output:${StatsNewDir} Orig:${StatsOrigDir} Done:${StatsDoneDir} Dontlike:${StatsDontlikeDir} Error:${StatsErrorDir} Double:${StatsDoubleDir}"
}

# Main  ------------------------------------------------------------------------

while getopts "d:hm:p:q:sv" OPTION
do
# When you need an argument that needs a value, you put the ":" right after the argument in the optstring. If your var is just a flag, withou any additional argument, just leave the var, without the ":" following it.
  case $OPTION in
    d)
      DEBUG=$OPTARG
      ;;
    h)
      usage
      exit 1
      ;;
    m)
      METHOD=$OPTARG
      ;;
    p)
      PROFILE=$OPTARG
      load_profile
      ;;
    q)
      DEBUG=0
      VERBOSE=0
      # add LOGGING variable and change logging function to be able to turn 
      # all output off
      ;;
    s)
      STREAMRIPPER_START=1 
      ;;
    v)
      VERBOSE=1
      ;;
  esac
done

if [[ -z $PROFILE ]] || [[ -z $METHOD ]] 
then
     usage
     exit 1
fi

createDirs

while true
do
  startStream
  loop_fadecut
  showStats
  logging -n "Main(): Loop until we're finished" >&2
  sleep 120
done
