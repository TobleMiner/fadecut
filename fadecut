#!/bin/bash
#
# This file is part of fadecut
# https://github.com/micressor/fadecut
#
# fadecut is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# fadecut is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with fadecut.  If not, see <http://www.gnu.org/licenses/>.

# Constants --------------------------------------------------------------------
# Debug level 1-3
DEBUG=0

# Verbosity level
VERBOSE=0

# loop interval in seconds
LOOP_INTERVAL=120

# restart interval streamripper
RESTART_STREAMRIPPER_INTERVAL=900

# which files to work on
FILES=*.mp3

# Main directory of fadecut
PWD=`pwd`

# prefered destination fileformat. (ogg/mp3)
ENCODING=mp3

# preferred fadecut method. <sox|cut|split>
METHOD=sox

# fadecut's profil dir
PROFILDIR="${HOME}/.fadecut"

# fadcut's workdir
WORKDIR="${PWD}/workdir"

# where to put fadecut'ted files
OUTPUTDIR="${PWD}/new"

# where to put the uncutted original files
ORIGDIR="${PWD}/orig"

# here are the already fadecut'ted files, which are tested and we listened to 
# already
DONEDIR="${PWD}/done"

# here we put songs which we don't like
DONTLIKEDIR="${PWD}/dontlike"

# here are the files, with which we got an error
# in same folder i put files, which i was listening to and found advertisement 
# or bad cutting
ERRORDIR="${PWD}/error"

# here will be the files which we have already downloaded and which we got again
DOUBLEDIR="${PWD}/double"

# enqueue to rhythmbox or vlc player (0=false, 1=true)
ENQUEUE=0

# standard errorlevel definitions
E_NOARGS=65

# start streamripper
STREAMRIPPER_START=0 

# stream ripper binary
BIN_STREAMRIPPER="/usr/bin/streamripper"


# streamripper options
STREAMRIPPER_OPTS="--quiet -o always -T"

# Variables --------------------------------------------------------------------
PidStreamripper=""
IdleCounter=-1
IdleSeconds=0
MissingVar=""
Fdst=""
# Functions --------------------------------------------------------------------

usage()
{
cat << EOF

usage: $0 -p <profilename> [other options]

OPTIONS:
  -d    Debug: -d 0|1|2|3 (level 0 is standard, -d without number is like 1)
  -h	Show this message
  -m    Method <sox|cut|split>
  -p    Profile <profilename>
  -q	Quiet
  -s    Stream (and rip), start streamripper
  -v	Verbose

EOF
}

logging()
#
# Description:  It writes messages to logfile or standard output.
#
# Parameter  :  $1 - the level of message
#               $2 - the message
#
# Std. Output:  Logging messages.
#
{
 time="$(date +%H):$(date +%M):$(date +%S)"
 prefix=""
 stderr=-1

 case $1 in
   -e)     prefix="Error:   " stderr=1;;
   -i)     prefix="Info:    " stderr=0;;
   -n)     prefix="Notice:  " stderr=0;;
   -s)     prefix="Success: " stderr=0;;
   -w)     prefix="Warning: " stderr=1;;
   -d)     prefix="Debug:   " stderr=1;;
   -a)     prefix="         " stderr=1;;
 esac
 shift

 if [ "${stderr}" -eq 1 ];
 then
   echo "${time} ${prefix}" ${1} >&2
 else
   echo "${time} ${prefix}" ${1}
 fi
}

createDirs()
# create necessary directories
{
if [ ${DEBUG} -ge 2 ]; then set -x
fi

if [ ! -d "${PROFILDIR}/profiles" ]; then
  mkdir -p "${PROFILDIR}/profiles"
fi

if [ ! -d "$OUTPUTDIR" ]; then
  mkdir -p "$OUTPUTDIR"
fi

if [ ! -d "$ORIGDIR" ]; then
  mkdir -p "$ORIGDIR"
fi

if [ ! -d "$DONEDIR" ]; then
  mkdir -p "$DONEDIR"
fi

if [ ! -d "$DONTLIKEDIR" ]; then
  mkdir -p "$DONTLIKEDIR"
fi

if [ ! -d "$ERRORDIR" ]; then
  mkdir -p "$ERRORDIR"
fi

if [ ! -d "$DOUBLEDIR" ]; then
  mkdir -p "$DOUBLEDIR"
fi

if [ ! -d "$WORKDIR" ]; then
  mkdir -p "$WORKDIR"
fi

return 0
}

startStream()
# fork a stream process
{
if [ ${DEBUG} -ge 1 ]; then set -x
fi

cd "${WORKDIR}"

if [ ! -x ${BIN_STREAMRIPPER} ]; then
  logging -e "Ooops! No streamripper found"
  shutdown_fadecut
fi

if [ ${VERBOSE} -ge 1 ];
then
  # opposite of quiet
  STREAMRIPPER_OPTS="-o always -T"
fi

if [ ! "$(pidof streamripper)" ] && [ "$STREAMRIPPER_START" == "1" ];
then
  ${BIN_STREAMRIPPER} ${STREAM_URL} -d . -s ${STREAMRIPPER_OPTS} & 
  PidStreamripper=$!
  logging -s "${BIN_STREAMRIPPER} started pid=${PidStreamripper}"
else
  logging -n "${BIN_STREAMRIPPER} running pid=${PidStreamripper}"
fi

cd "${PWD}"

return 0
}

shutdown_streamripper()
# Shutting down streamripper
{
if [ "$(pidof streamripper)" ];
then 
  logging -i "Shutdown streamripper" 
  kill ${PidStreamripper}
  if [ "$(pidof streamripper)" ];
  then
    logging -w "Streamripper still here, killing it!"
    kill -9 ${PidStreamripper}
  fi
fi
}

shutdown_fadecut()
# shutting down fadecut
{
if [ ${DEBUG} -ge 1 ]; then set -x
fi
shutdown_streamripper
showStats
logging -i "Shutting down fadecut..."
exit $?
}

queueSong()
# queue song to music players
{
if [ $ENQUEUE -eq "1" ]; then
  if [ "$(pidof rhythmbox)" ];
  then
    logging -i "Rhythmbox is running, adding to playlist"
    rhythmbox-client --enqueue "$OUTPUTDIR"/"$Fdst"
  fi
  if [ "$(pidof vlc)" ];
  then
    # enqueue to vlc player if in one instance mode (default disabled)
    logging -i "vlc is running, adding to playlist"
    vlc --playlist-enqueue "$OUTPUTDIR"/"$Fdst"
  fi
fi
}

control_c()
# run if user hits control-c
{
if [ ${DEBUG} -ge 1 ]; then set -x
fi
  logging -n "CTRL-C catched"
  shutdown_fadecut
}
# trap keyboard interrupt (control-c)
trap control_c SIGINT

loop_fadecut()
{
if [ ${DEBUG} -ge 1 ]; then set -x
fi
RetLoop=0

cd "${WORKDIR}"
for F in $FILES
do
  if [ "$F" == "$FILES" ]; then
    let IdleCounter=$((IdleCounter+1))
    let IdleSeconds=$((IdleCounter*LOOP_INTERVAL))
    logging -n "no files to process, idle for ${IdleSeconds} seconds"
    if [ $STREAMRIPPER_START == "0" ];
    then 
      shutdown_fadecut
    else
      if [ ${IdleSeconds} -ge ${RESTART_STREAMRIPPER_INTERVAL} ];
      then
        logging -w "Oops! Seems to hang, restarting it"
	shutdown_streamripper
	startStream
        IdleCounter=0
      fi
    fi
    break
  fi
  IdleCounter=0

  logging -i "Processing:"
  logging -a "$F"

  if [ -f "$DONEDIR"/"$F" ]; then
    logging -i "$F already exists in $DONEDIR -> moving to $DOUBLEDIR ..."
    mv "$F" "$DOUBLEDIR"
    continue
  fi

  if [ -f "$OUTPUTDIR"/"$F" ]; then
    logging -i "$F already exists in $OUTPUTDIR -> moving to $DOUBLEDIR ..."
    mv "$F" "$DOUBLEDIR"
    continue
  fi

  if [ -f "$DONTLIKEDIR"/"$F" ]; then
    logging -i "$F already exists in $DONTLIKEDIR -> deleting ..."
    rm "$F"
    continue
  fi

  set -o pipefail
  ARTIST=`echo $F | sed -e 's/ -.*//' | iconv -f UTF-8 -t ISO8859-1`
  TITLE=`echo $F | sed -e 's/^.* - //' | sed -e 's/.mp3//' | iconv -f UTF-8 -t ISO8859-1`

  if [ "$METHOD" == "sox" ]; then
    LENGTH=`soxi -D "$F" | sed -e 's/\..*//'`
    let TRIMLENGTH=$((LENGTH-TRIM_BEGIN-TRIM_END))
    let FADE_OUT_START=$((TRIMLENGTH-FADE_OUT))

    logging -i "Encoding to ${ENCODING}"
    if [ "${ENCODING}" == "mp3" ]; then
      mp3Encoding "${F}"
    fi

    if [ "${ENCODING}" == "ogg" ]; then
      oggEncoding "${F}"
    fi
  fi

  if [ "$METHOD" == "cut" ]; then
    if [ "${ENCODING}" == "mp3" ]; then
      logging -i "cutting with cutmp3 ..."
      #quiet:
      #echo nnnnpwq | cutmp3 -i "$F" -O "$OUTPUTDIR"/"$F" -q -c &> /dev/null
      
      #verbose:
      echo nnnnnnpwq | cutmp3 -i "$F" -O "$OUTPUTDIR"/"$F" -q -c || RetLoop=3
    else
      logging -e "This method works only for mp3 encoding"
    fi
  fi

  if [ "$METHOD" == "split" ]; then
    if [ "${ENCODING}" == "mp3" ]; then
      logging -i "splitting with mp3splt ..."
      Fsrc=$(echo $F | sed 's/.mp3//g')
      #verbose   : mp3splt -N -s -p nt=3 "$F"
      #quiet     : mp3splt -q -N -s -p nt=3 "$F"
      #more quiet: mp3splt -Q -N -s -p nt=3 "$F"
      mp3splt -Q -N -s -p nt=3 "$F"
      Ftmp=`ls -1t "$Fsrc"* | head -1`
      Fdst=$(echo $Ftmp | sed 's/ /_/g')
      cp "$Ftmp" "$OUTPUTDIR"/"$Fdst"
      rm -f "$Fsrc"_silence_*.*
    else
      logging -e "This method works only for mp3 encoding"
    fi
  fi
  
  if [ "${RetLoop}" -eq "0" ]; then
    logging -s "Ready for listening:"
    logging -a "$Fdst"
    mv "$F" "$ORIGDIR"
  else
    mv "$F" "$ERRORDIR"
      # when sox or lame are receiving SIGINT they exit with return-code > 0
      # the ctrl_c function does not catch this case, so we have to break here
    logging -n "loop_fadecut(): Oops! Something was wrong."
    logging -e "loop_fadecut(): returnvalue=$RetLoop"
    shutdown_fadecut
  fi
  set +o pipefail

queueSong
showStats
done
cd "${PWD}"
}

load_profile()
{
createDirs
logging -i "Loading profile file(s):"

if [ -r "${PROFILDIR}/fadecutrc" ]; then
  logging -a "${PROFILDIR}/fadecutrc"
  . "${PROFILDIR}/fadecutrc"
fi

if [ ! -r "${PROFILDIR}/profiles/${PROFILE}" ]; then
  logging -e "Can't not load profile ${PROFILDIR}/profiles/${PROFILE}"
  exit 1
fi

logging -a "${PROFILDIR}/profiles/${PROFILE}"
. "${PROFILDIR}/profiles/${PROFILE}"

check_profile
}

check_profile()
# Check profile, we need all variables to work
{
RetCheckProfile=0
MissingVar=""

if [ -z "$STREAM_URL" ]; then 
  RetCheckProfile=1
  MissingVar="STREAM_URL"
fi
if [ -z "$COMMENT" ]; then 
  RetCheckProfile=1
  MissingVar="COMMENT"
fi
if [ -z "$TRIM_BEGIN" ]; then 
  RetCheckProfile=1
  MissingVar="TRIM_BEGIN"
fi
if [ -z "$TRIM_END" ]; then 
  RetCheckProfile=1
  MissingVar="TRIM_END"
fi
if [ -z "$FADE_IN" ]; then 
  RetCheckProfile=1
  MissingVar="FADE_IN"
fi
if [ -z "$FADE_OUT" ]; then 
  RetCheckProfile=1
  MissingVar="FADE_OUT"
fi

if [ ${RetCheckProfile} -eq 1 ]; 
then 
  logging -e "${PROFILDIR}/profiles/${PROFILE}:"
  logging -a "${MissingVar} not defined"
  shutdown_fadecut
fi
}

showStats()
# Show file statistics
{
StatsNewDir=`find "${OUTPUTDIR}" -type f | wc -l`
StatsOrigDir=`find "${ORIGDIR}" -type f | wc -l`
StatsDoneDir=`find "${DONEDIR}" -type f | wc -l`
StatsDontlikeDir=`find "${DONTLIKEDIR}" -type f | wc -l`
StatsErrorDir=`find "${ERRORDIR}" -type f | wc -l`
StatsDoubleDir=`find "${DOUBLEDIR}" -type f | wc -l`
logging -i "showStats: Output:${StatsNewDir} Orig:${StatsOrigDir} Done:${StatsDoneDir} Dontlike:${StatsDontlikeDir} Error:${StatsErrorDir} Double:${StatsDoubleDir}"
}

oggEncoding()
# Encoding to ogg
{
Fdst=$(echo $F | sed 's/.mp3/.ogg/g')
nice -15 sox -V1 "$F" -t wav - trim $TRIM_BEGIN $TRIMLENGTH \
  fade t $FADE_IN $FADE_OUT_START $FADE_OUT | \
  oggenc - --quiet -t "$TITLE"  -a  "$ARTIST" -G "$GENRE" \
	-c "comment=$COMMENT" -o "$OUTPUTDIR"/"$Fdst" || RetLoop=3
if [ ${VERBOSE} -ge 1 ];
then
  ogginfo "$OUTPUTDIR"/"$Fdst" || RetLoop=3
fi
}
mp3Encoding()
# Encoding to mp3
{
Fsrc=${1}
Fdst=${Fsrc}
nice -15 sox -V1 "$Fsrc" -t wav - trim $TRIM_BEGIN $TRIMLENGTH \
  fade t $FADE_IN $FADE_OUT_START $FADE_OUT | \
  lame --quiet --add-id3v2 --ta "$ARTIST" --tt "$TITLE" \
  --tg "$GENRE" --tc "$COMMENT" - "$OUTPUTDIR"/"$Fdst" || RetLoop=3
}

# Main  ------------------------------------------------------------------------

while getopts ":d:hm:p:qsv" OPTION
do
# When you need an argument that needs a value, you put the ":" right after the argument in the optstring. If your var is just a flag, withou any additional argument, just leave the var, without the ":" following it.
  case $OPTION in
    d)
      DEBUG=$OPTARG
      ;;
    h)
      usage
      exit 1
      ;;
    m)
      METHOD=$OPTARG
      ;;
    p)
      PROFILE=$OPTARG
      load_profile
      ;;
    q)
      DEBUG=0
      VERBOSE=0
      # add LOGGING variable and change logging function to be able to turn 
      # all output off
      ;;
    s)
      STREAMRIPPER_START=1 
      ;;
    v)
      VERBOSE=1
      ;;
    \?)
      logging -e "Invalid option: -$OPTARG" >&2
      usage
      exit 1
      ;;
    :)
      logging -e "Option -$OPTARG requires an argument." >&2
      exit 1
      ;;
  esac
done

if [[ -z $PROFILE ]] || [[ -z $METHOD ]] 
then
     usage
     exit 1
fi

while true
do
  startStream
  loop_fadecut
  if [ ${VERBOSE} -ge 1 ]; then logging -n "Main(): Loop until we're finished"
  fi
sleep ${LOOP_INTERVAL}
done
